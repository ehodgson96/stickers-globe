<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./data/mapPointer.png" type="image/png" />
    <title>Shroom Sticker Globe</title>
    <!-- Pixel-style font -->
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --ink: #f2f2f2;
        --dim-ink: #cfcfcf;
        --panel: #0b0b12;
        --accent: #e74c3c;
        --accent-dark: #9a2b21;
        --green: #88ff88;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #0a0a0a;
        color: var(--ink);
        overflow: hidden;
        font-family: "VT323", monospace;
      }

      .container {
        display: flex;
        height: 100vh;
      }
      #globe-container {
        flex: 1;
        position: relative;
      }

      /* ‚îÄ‚îÄ‚îÄ SIDEBAR: CRT panel look ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      .sidebar {
        width: 340px;
        background: var(--panel);
        position: relative;
        overflow-y: auto;
        padding: 16px 14px 18px;
        border-left: 2px solid #fff; /* outer white frame */
        box-shadow: inset 0 0 0 2px var(--panel-edge),
          /* inner dark frame */ inset 0 0 0 6px var(--panel-inner),
          /* thick inner bezel */ 0 0 0 1px #000; /* crisp outer edge */
        image-rendering: pixelated;
        font-family: "VT323", ui-monospace, monospace;
      }

      /* CRT scanlines */
      .sidebar::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: repeating-linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.07) 0px,
          rgba(255, 255, 255, 0.07) 1px,
          transparent 1px,
          transparent 3px
        );
        opacity: 0.35; /* adjust intensity */
        mix-blend-mode: overlay;
      }

      /* Header block */
      .header {
        position: sticky;
        top: 0;
        z-index: 2;
        background: linear-gradient(#0f0f1e, #0b0b15);
        border: 2px solid #fff;
        box-shadow: inset 0 0 0 2px #1d1d30, 0 3px 0 0 rgba(255, 255, 255, 0.15);
        padding: 14px 12px 12px;
        text-align: center;
      }

      .header h1 {
        font-family: "VT323", ui-monospace, monospace;
        font-size: 28px;
        letter-spacing: 3px;
        color: var(--ink);
        text-shadow: 0 1px 0 #000, 0 0 6px rgba(255, 255, 255, 0.08);
        margin-bottom: 6px;
      }

      /* dashed rule like the mock */
      .header .rule {
        height: 2px;
        margin: 6px auto 8px;
        width: 92%;
        background: repeating-linear-gradient(
          to right,
          #fff 0 6px,
          transparent 6px 12px
        );
        opacity: 0.85;
        filter: drop-shadow(0 1px 0 #000);
      }

      .header p {
        font-size: 18px;
        line-height: 1;
        color: var(--dim-ink);
        letter-spacing: 2px;
        text-shadow: 0 1px 0 #000;
      }

      .sticker-count {
        margin: 14px 4px 10px;
        padding: 8px 10px;
        font-size: 18px;
        letter-spacing: 2px;
        color: var(--dim-ink);
        border: 2px solid #fff;
        box-shadow: inset 0 0 0 2px #1d1d30;
        background: #05050a;
      }

      #sticker-list {
        padding: 0 4px 12px;
        position: relative;
        z-index: 1;
      }

      /* Item layout: title (left) + date (right), coords below */
      .sticker-item {
        background: #0a0a12;
        border: 2px solid #2b2b35;
        margin: 10px 4px;
        padding: 8px 10px 7px;
        cursor: pointer;
        box-shadow: 0 2px 0 rgba(0, 0, 0, 0.8), inset 0 0 0 2px #141422;
        transition: transform 0.06s linear, box-shadow 0.06s linear,
          border-color 0.06s linear;
      }
      .sticker-item:hover {
        border-color: #3b3b45;
        box-shadow: 0 3px 0 rgba(0, 0, 0, 0.85), inset 0 0 0 2px #17172a;
        transform: translateY(-1px);
      }

      .sticker-item.active {
        background: var(--accent);
        border-color: #ffffff;
        color: #fff;
        box-shadow: 0 3px 0 rgba(0, 0, 0, 0.9),
          inset 0 0 0 2px var(--accent-dark),
          inset 0 -8px 0 0 rgba(0, 0, 0, 0.15); /* bottom bevel like mock */
        transform: translateY(0);
      }

      .sticker-row {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: baseline;
        gap: 8px;
        margin-bottom: 2px;
      }

      .sticker-title {
        font-size: 22px;
        letter-spacing: 2px;
        text-shadow: 0 1px 0 #000;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .sticker-date {
        font-size: 20px;
        letter-spacing: 2px;
        color: var(--dim-ink);
        text-shadow: 0 1px 0 #000;
      }

      .sticker-item.active .sticker-date {
        color: #fff;
      }

      .sticker-coords {
        font-size: 18px;
        color: var(--green);
        letter-spacing: 2px;
        text-shadow: 0 0 4px rgba(136, 255, 136, 0.25), 0 1px 0 #000;
        opacity: 0.95;
      }

      /* Hide the old square photo link button in this look */
      .sticker-link {
        display: none;
      }

      /* Scrollbar ‚Äì subtle, monochrome */
      .sidebar::-webkit-scrollbar {
        width: 12px;
      }
      .sidebar::-webkit-scrollbar-track {
        background: #0b0b12;
      }
      .sidebar::-webkit-scrollbar-thumb {
        background: #dcdcdc;
        border: 3px solid #0b0b12;
      }

      /* --- CONTROLS PANEL (retro CRT theme) --- */
      .controls {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        padding: 14px 18px 10px;
        font-family: "VT323", monospace;
        font-size: 18px;
        letter-spacing: 2px;
        color: #f2f2f2;
        background: #0e0e15;
        border: 2px solid #f2f2f2;
        box-shadow: inset 0 0 0 2px #1d1d30, 0 0 12px rgba(255, 255, 255, 0.1),
          2px 2px 0 rgba(0, 0, 0, 0.8);
        image-rendering: pixelated;
        position: absolute;
        overflow: hidden;
      }

      /* Subtle scanline overlay inside controls */
      .controls::after {
        content: "";
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.07) 0px,
          rgba(255, 255, 255, 0.07) 1px,
          transparent 1px,
          transparent 3px
        );
        opacity: 0.4;
        mix-blend-mode: overlay;
        pointer-events: none;
      }

      .controls p {
        margin: 3px 0;
        color: #b8b8b8;
        text-shadow: 0 1px 0 #000;
      }

      /* add a small heading bar to match sidebar style */
      .controls::before {
        content: "+ CONTROLS +";
        position: absolute;
        top: -16px;
        left: 50%;
        transform: translateX(-50%);
        background: #0e0e15;
        padding: 0 6px;
        font-size: 16px;
        letter-spacing: 2px;
        color: #f2f2f2;
      }
      .logo {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
      }
      .logo img {
        height: 150px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
      }

      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        .sidebar {
          width: 100%;
          height: 220px;
          border-left: none;
          border-top: 2px solid var(--ink);
        }
        #globe-container {
          height: calc(100vh - 220px);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="globe-container">
        <div class="logo">
          <img src="./data/ShroomSquad.png" alt="Shroom Squad Logo" />
        </div>
        <div class="controls">
          <p>üñ±Ô∏è Drag to orbit</p>
          <p>üîç Scroll to zoom</p>
        </div>
      </div>
      <div class="sidebar">
        <div class="header">
          <h1>+ STICKER SPOTS +</h1>
          <p>Your global sticker collection</p>
        </div>
        <div class="sticker-count" id="sticker-count"></div>
        <div id="sticker-list"></div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>

    <script>
      // Load sticker data from JSON file
      let stickerData = [];

      fetch("./data/stickers.json")
        .then((response) => response.json())
        .then((data) => {
          stickerData = data;
          initializeApp();
        })
        .catch((error) => {
          console.error("Error loading stickers.json:", error);
          stickerData = [];
          initializeApp();
        });

      function initializeApp() {
        // ===== Shaders (world-space lighting so camera doesn't affect it) =====
        const vertexShader = `
          varying vec2 vUv;
          varying vec3 vNormalWorld;

          void main() {
            vUv = uv;
            vNormalWorld = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const fragmentShader = `
          uniform sampler2D uDayTexture;
          uniform sampler2D uNightTexture;
          uniform vec3 uSunDirectionWorld;

          varying vec2 vUv;
          varying vec3 vNormalWorld;

          void main() {
            vec3 dayColor = texture2D(uDayTexture, vUv).rgb;
            vec3 nightColor = texture2D(uNightTexture, vUv).rgb;

            float sunIntensity = dot(vNormalWorld, normalize(uSunDirectionWorld));
            float mixFactor = smoothstep(-0.1, 0.1, sunIntensity);

            vec3 color = mix(nightColor, dayColor, mixFactor);
            float spec = pow(max(dot(vNormalWorld, normalize(uSunDirectionWorld)), 0.0), 16.0) * 0.4;
            color += vec3(spec);

            gl_FragColor = vec4(color, 1.0);
          }
        `;

        // ===== Three.js setup =====
        const container = document.getElementById("globe-container");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          10000
        );
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x0a0a0a);
        container.appendChild(renderer.domElement);

        // ---- ORBIT STATE ----
        const orbit = {
          radius: 2.5,
          theta: 0,
          phi: Math.PI / 2,
          minRadius: 1.5,
          maxRadius: 5.0,
          minPhi: 0.05,
          maxPhi: Math.PI - 0.05,
          lockedMarker: null,
        };

        // Simple animation token to allow cancellation on drag
        let orbitAnim = null; // { cancel: boolean }

        function updateCameraFromOrbit() {
          const x = orbit.radius * Math.sin(orbit.phi) * Math.sin(orbit.theta);
          const y = orbit.radius * Math.cos(orbit.phi);
          const z = orbit.radius * Math.sin(orbit.phi) * Math.cos(orbit.theta);
          camera.position.set(x, y, z);
          camera.lookAt(0, 0, 0);
        }

        updateCameraFromOrbit();

        // Textures
        const textureLoader = new THREE.TextureLoader();
        const dayTexture = textureLoader.load("./data/1_earth_8k.jpg");
        const nightTexture = textureLoader.load("./data/5_night_8k.jpg");
        dayTexture.colorSpace = THREE.SRGBColorSpace;
        nightTexture.colorSpace = THREE.SRGBColorSpace;

        // Starfield (static)
        function createStarfield() {
          const canvas = document.createElement("canvas");
          canvas.width = 2048;
          canvas.height = 1024;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < 2000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const b = Math.random();
            const size = b * 1.5;
            ctx.fillStyle = `rgba(255,255,255,${b})`;
            ctx.fillRect(x, y, size, size);
          }
          return new THREE.CanvasTexture(canvas);
        }

        const starfieldGeometry = new THREE.SphereGeometry(100, 64, 64);
        const starfieldTexture = createStarfield();
        const starfieldMaterial = new THREE.MeshBasicMaterial({
          map: starfieldTexture,
          side: THREE.BackSide,
          castShadow: false,
          receiveShadow: false,
        });
        const starfield = new THREE.Mesh(starfieldGeometry, starfieldMaterial);
        scene.add(starfield);

        // Globe
        const globeGeometry = new THREE.SphereGeometry(1, 16, 10);
        const globeMaterial = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader,
          uniforms: {
            uDayTexture: new THREE.Uniform(dayTexture),
            uNightTexture: new THREE.Uniform(nightTexture),
            uSunDirectionWorld: new THREE.Uniform(
              new THREE.Vector3(-1, 0.5, 0.2).normalize()
            ),
          },
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Moon
        const moonGeometry = new THREE.SphereGeometry(0.27, 8, 6);
        const moonTexture = textureLoader.load("./data/moon.jpg");
        moonTexture.colorSpace = THREE.SRGBColorSpace;
        const moonMaterial = new THREE.MeshStandardMaterial({
          map: moonTexture,
          roughness: 1,
          metalness: 0,
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(3, 0, 0);
        globe.add(moon);

        // Mars
        const marsGeometry = new THREE.SphereGeometry(2, 8, 6);
        const marsTexture = textureLoader.load("./data/mars.jpg");
        marsTexture.colorSpace = THREE.SRGBColorSpace;
        const marsMaterial = new THREE.MeshStandardMaterial({
          map: marsTexture,
          roughness: 1,
          metalness: 0,
        });
        const mars = new THREE.Mesh(marsGeometry, marsMaterial);
        mars.position.set(25, 0, 0);
        scene.add(mars);

        // --- Load custom GLB model to orbit the globe ---
        const gltfLoader = new THREE.GLTFLoader();

        // üõ∏ Add UFO
        addOrbitingModel("./data/ufo.glb", {
          radius: 2,
          speed: 0.0012,
          scale: [0.1, 0.1, 0.1],
          tilt: THREE.MathUtils.degToRad(-25), // orbit in opposite tilted plane
          ySpin: true, // enable Y-axis spin
        });

        addOrbitingModel("./data/cow.glb", {
          radius: 1.1,
          speed: 0.0008,
          scale: [0.01, 0.01, 0.01],
          tilt: THREE.MathUtils.degToRad(15), // orbit in opposite tilted plane
          zSpin: true, // enable Z-axis spin
          ySpin: true, // enable Y-axis spin
        });
        addOrbitingModel("./data/rocket.glb", {
          radius: 1.8,
          speed: -0.0006,
          scale: [0.002, 0.002, 0.002],
          tilt: THREE.MathUtils.degToRad(30), // orbit in opposite tilted plane
          zSpin: true, // enable Z-axis spin
        });
        addOrbitingModel("./data/Satellite.glb", {
          radius: 1.4,
          speed: 0.0002,
          scale: [0.003, 0.003, 0.003],
          tilt: THREE.MathUtils.degToRad(5), // orbit in opposite tilted plane
          zSpin: true, // enable Z-axis spin
        });
        addOrbitingModel("./data/Satellite.glb", {
          radius: 1.3,
          speed: -0.0005,
          scale: [0.003, 0.003, 0.003],
          tilt: THREE.MathUtils.degToRad(28), // orbit in opposite tilted plane
          zSpin: true, // enable Z-axis spin
          ySpin: true, // enable Y-axis spin
        });
        addOrbitingModel("./data/Satellite.glb", {
          radius: 1.5,
          speed: 0.0003,
          scale: [0.003, 0.003, 0.003],
          tilt: THREE.MathUtils.degToRad(72), // orbit in opposite tilted plane
          zSpin: true, // enable Z-axis spin
        });
        addOrbitingModel("./data/HubbleTelescope.glb", {
          radius: 1.3,
          speed: 0.0003,
          scale: [0.003, 0.003, 0.003],
          tilt: THREE.MathUtils.degToRad(-40), // orbit in opposite tilted plane
          ySpin: true, // enable Y-axis spin
        });
        function addOrbitingModel(path, options) {
          gltfLoader.load(
            path,
            (gltf) => {
              const model = gltf.scene;
              model.scale.set(...(options.scale || [0.2, 0.2, 0.2]));
              globe.add(model); // attach to globe so it moves with Earth's rotation

              // Store orbit data for animation
              model.userData.orbit = {
                radius: options.radius || 2.5,
                speed: options.speed || 0.001,
                angle: Math.random() * Math.PI * 2,
                tilt: options.tilt || 0, // radians
                zSpin: options.zSpin || false, // whether to spin around Z axis
                ySpin: options.ySpin || false, // whether to spin around Z axis
              };

              // Optional: disable cast/receive shadows
              model.traverse((n) => {
                if (n.isMesh) {
                  n.castShadow = false;
                  n.receiveShadow = false;
                }
              });

              console.log(`${path} loaded`);
            },
            (xhr) =>
              console.log(
                `${path}: ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`
              ),
            (err) => console.error(`Error loading ${path}:`, err)
          );
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(5, 3, 5);
        scene.add(pointLight);

        // --- Marker scaling config (relative to zoom) ---
        const markerScale = {
          base: 0.15, // scale at referenceRadius
          min: 0.07, // absolute minimum world-scale
          max: 0.3, // absolute maximum world-scale
          referenceRadius: 2.5, // radius at which base applies (matches initial orbit)
        };

        // Markers
        const markers = [];
        const markerGroup = new THREE.Group();
        globe.add(markerGroup);

        function latLngToVector3(lat, lng) {
          const phi = ((90 - lat) * Math.PI) / 180;
          const theta = ((lng + 180) * Math.PI) / 180;
          const x = -Math.sin(phi) * Math.cos(theta);
          const y = Math.cos(phi);
          const z = Math.sin(phi) * Math.sin(theta);
          return new THREE.Vector3(x, y, z).normalize();
        }

        const pointerTexture = new THREE.TextureLoader().load(
          "./data/mapPointer.png"
        );

        stickerData.forEach((sticker, index) => {
          const pos = latLngToVector3(sticker.lat, sticker.lng);

          const spriteContainer = new THREE.Object3D();
          spriteContainer.position.copy(pos.multiplyScalar(1.02));

          const spriteMaterial = new THREE.SpriteMaterial({
            map: pointerTexture,
            sizeAttenuation: true,
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(markerScale.base, markerScale.base, 1); // initial; will be updated per-zoom
          sprite.position.y = 0.03;
          sprite.userData = { index, sticker };

          spriteContainer.add(sprite);
          markerGroup.add(spriteContainer);
          markers.push(sprite);
        });

        // --- Scale markers based on orbit.radius with clamped limits ---
        function updateMarkerScales() {
          const factor = orbit.radius / markerScale.referenceRadius; // >1 when zoomed out; <1 when zoomed in
          const s = THREE.MathUtils.clamp(
            markerScale.base * factor,
            markerScale.min,
            markerScale.max
          );
          for (let i = 0; i < markers.length; i++) {
            markers[i].scale.set(s, s, 1);
          }
        }
        // initial scale
        updateMarkerScales();

        // ----- Mouse interaction -----
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const dragSensitivity = 0.005;
        const dragSensitivityY = 0.005;

        container.addEventListener("mousedown", (e) => {
          isDragging = true;
          // Cancel any running animation and unlock marker on drag start
          if (orbitAnim) orbitAnim.cancel = true;
          orbit.lockedMarker = null;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          orbit.theta -= deltaX * dragSensitivity;
          orbit.phi -= deltaY * dragSensitivityY;
          orbit.phi = Math.max(orbit.minPhi, Math.min(orbit.maxPhi, orbit.phi));

          updateCameraFromOrbit();

          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener("mouseup", () => {
          isDragging = false;
        });
        container.addEventListener("mouseleave", () => {
          isDragging = false;
        });

        // Zoom (adjust orbit radius)
        container.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const zoomFactor = 0.0015;
            const newRadius = orbit.radius + e.deltaY * zoomFactor;
            orbit.radius = Math.max(
              orbit.minRadius,
              Math.min(orbit.maxRadius, newRadius)
            );
            updateCameraFromOrbit();
            updateMarkerScales(); // reflect zoom immediately
          },
          { passive: false }
        );

        // Sidebar
        const stickerList = document.getElementById("sticker-list");
        const stickerCount = document.getElementById("sticker-count");
        stickerCount.textContent = `${stickerData.length} stickers found`;
        stickerData.forEach((sticker, index) => {
          const item = document.createElement("div");
          item.className = "sticker-item";
          item.innerHTML = `
            <div class="sticker-row">
              <div class="sticker-title">${sticker.title}</div>
              </div>
              <div class="sticker-row">
              <div class="sticker-date">${sticker.date}</div>
              </div>
            <div class="sticker-coords">${sticker.lat.toFixed(
              4
            )}¬∞, ${sticker.lng.toFixed(4)}¬∞</div>
          `;
          item.addEventListener("click", (e) => {
            selectSticker(index);
          });
          stickerList.appendChild(item);
        });

        // Utility: vector -> spherical angles
        function vectorToAngles(v) {
          const vn = v.clone().normalize();
          const phi = Math.acos(THREE.MathUtils.clamp(vn.y, -1, 1)); // 0..PI
          const theta = Math.atan2(vn.x, vn.z); // -PI..PI
          return { theta, phi };
        }

        function shortestAngleDelta(a, b) {
          let d = b - a;
          while (d > Math.PI) d -= 2 * Math.PI;
          while (d < -Math.PI) d += 2 * Math.PI;
          return d;
        }

        /*************  ‚ú® Windsurf Command ‚≠ê  *************/
        /**
         * EaseInOutQuad - ease in/out quad function for animations
         * @param {number} t - value between 0 and 1
         * @returns {number} eased value
         * @description
         * This function maps an input value `t` between 0 and 1 to an eased value using a quadratic ease-in/out function.
         * The function returns 0 at `t=0` and 1 at `t=1`, and the curve is symmetric around `t=0.5`.
         */
        /*******  1cd37865-fadf-42e3-aebf-3a26f8d49a49  *******/
        function easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function animateOrbitTo(
          targetTheta,
          targetPhi,
          duration = 700,
          onDone = () => {}
        ) {
          // Cancel any existing animation
          if (orbitAnim) orbitAnim.cancel = true;

          const token = { cancel: false };
          orbitAnim = token;

          const startTheta = orbit.theta;
          const startPhi = orbit.phi;
          const dTheta = shortestAngleDelta(startTheta, targetTheta);
          const dPhi = targetPhi - startPhi;

          const t0 = Date.now();

          function step() {
            if (token.cancel) return;
            const t = Math.min((Date.now() - t0) / duration, 1);
            const e = easeInOutQuad(t);

            orbit.theta = startTheta + dTheta * e;
            orbit.phi = startPhi + dPhi * e;

            updateCameraFromOrbit();
            updateMarkerScales(); // keep scale smooth during fly-to

            if (t < 1) {
              requestAnimationFrame(step);
            } else {
              onDone();
            }
          }
          requestAnimationFrame(step);
        }

        function selectSticker(index) {
          document.querySelectorAll(".sticker-item").forEach((item, i) => {
            item.classList.toggle("active", i === index);
          });

          // Reset colours
          stickerData.forEach((_, i) => {
            const spriteContainer = markerGroup.children[i];
            const sprite = spriteContainer.children[0];
            sprite.material.color.setHex(0xffffff);
          });

          // Highlight selected pin
          const spriteContainer = markerGroup.children[index];
          const sprite = spriteContainer.children[0];
          sprite.material.color.setHex(0xe74c3c);

          // Determine target orbit angles to face the marker
          const worldPos = new THREE.Vector3();
          spriteContainer.getWorldPosition(worldPos);
          const { theta: targetTheta, phi: targetPhiRaw } =
            vectorToAngles(worldPos);
          const targetPhi = THREE.MathUtils.clamp(
            targetPhiRaw,
            orbit.minPhi,
            orbit.maxPhi
          );

          // During animation: ensure we are not locked (we'll lock after)
          orbit.lockedMarker = null;

          // Animate camera to marker direction, then lock to it
          animateOrbitTo(targetTheta, targetPhi, 700, () => {
            if (orbitAnim && orbitAnim.cancel) return;
            orbit.lockedMarker = spriteContainer;
          });
        }

        // Animation loop
        let moonOrbitAngle = 15;
        const moonOrbitRadius = 3;
        const moonOrbitSpeed = 0.001;

        let marsOrbitAngle = 0;
        const marsOrbitRadius = 25;
        const marsOrbitSpeed = -0.00001;

        function animate() {
          requestAnimationFrame(animate);

          // Gentle Earth spin (optional)
          globe.rotation.y += 0.0005;

          // Orbit the moon around Earth
          moonOrbitAngle += moonOrbitSpeed;
          moon.position.x = Math.cos(moonOrbitAngle) * moonOrbitRadius;
          moon.position.z = Math.sin(moonOrbitAngle) * moonOrbitRadius;
          moon.rotation.y += 0.001;

          // Orbit the mars around Earth
          marsOrbitAngle += marsOrbitSpeed;
          mars.position.x = Math.cos(marsOrbitAngle) * marsOrbitRadius;
          mars.position.z = Math.sin(marsOrbitAngle) * marsOrbitRadius;
          mars.rotation.y += 0.001;

          globe.traverse((obj) => {
            if (obj.userData.orbit) {
              const o = obj.userData.orbit;
              o.angle += o.speed;
              const r = o.radius;

              // Apply tilt
              const tiltMatrix = new THREE.Matrix4().makeRotationX(o.tilt);
              const pos = new THREE.Vector3(
                Math.cos(o.angle) * r,
                0,
                Math.sin(o.angle) * r
              ).applyMatrix4(tiltMatrix);

              obj.position.copy(pos);
              if (o.ySpin) {
                obj.rotation.y += 0.01; // spin
              }
              if (o.zSpin) {
                obj.rotation.z += 0.01;
              }
            }
          });
          // While locked: keep following the marker as Earth spins
          if (orbit.lockedMarker) {
            const worldPos = new THREE.Vector3();
            orbit.lockedMarker.getWorldPosition(worldPos);
            const { theta, phi } = vectorToAngles(worldPos);
            orbit.theta = theta;
            orbit.phi = THREE.MathUtils.clamp(phi, orbit.minPhi, orbit.maxPhi);
          }

          updateCameraFromOrbit();
          updateMarkerScales(); // keep marker size in sync every frame
          renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
          updateCameraFromOrbit();
          updateMarkerScales();
        });
      }
    </script>
  </body>
</html>
