<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sticker Globe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        #globe-container {
            flex: 1;
            position: relative;
        }
        
        .sidebar {
            width: 320px;
            background: #1a1a1a;
            overflow-y: auto;
            padding: 20px;
            border-left: 1px solid #333;
        }
        
        .header {
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 12px;
            color: #888;
        }
        
        .sticker-item {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .sticker-item:hover {
            background: #333;
            border-color: #e74c3c;
            transform: translateX(-5px);
        }
        
        .sticker-item.active {
            background: #e74c3c;
            color: #000;
            border-color: #c0392b;
        }
        
        .sticker-coords {
            font-family: monospace;
            font-size: 11px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .sticker-date {
            font-size: 12px;
            opacity: 0.6;
            margin-top: 3px;
        }
        
        .sticker-count {
            font-size: 14px;
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            z-index: 100;
        }
        
        .controls p {
            margin: 5px 0;
            color: #aaa;
        }
        
        .logo {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        .logo img {
            height: 100px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid #333;
            }
            #globe-container {
                height: calc(100vh - 200px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="globe-container">
            <div class="logo">
                <img src="./data/ShroomSquad.png" alt="Shroom Squad Logo">
            </div>
            <div class="controls">
                <p>üñ±Ô∏è Drag to rotate</p>
                <p>üîç Scroll to zoom</p>
            </div>
        </div>
        <div class="sidebar">
            <div class="header">
                <h1>Sticker Spots</h1>
                <p>Your global sticker collection</p>
            </div>
            <div class="sticker-count" id="sticker-count"></div>
            <div id="sticker-list"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Sample sticker data
        const stickerData = [
            {
                lat: 53.4859986,
                lng: -2.2354442,
                date: "05/04/25",
                title: "Red Post Box"
            },
            {
                lat: 51.5074,
                lng: -0.1278,
                date: "12/03/25",
                title: "London Spot"
            },
            {
                lat: 48.8566,
                lng: 2.3522,
                date: "20/02/25",
                title: "Paris Location"
            },
            {
                lat: 52.5200,
                lng: 13.4050,
                date: "08/02/25",
                title: "Berlin Find"
            },
            {
                lat: 55.7558,
                lng: 37.6173,
                date: "15/01/25",
                title: "Moscow Sticker"
            },
            {
                lat: 35.6762,
                lng: 139.6503,
                date: "22/12/24",
                title: "Tokyo Discovery"
            },
            {
                lat: -33.8688,
                lng: 151.2093,
                date: "10/12/24",
                title: "Sydney Find"
            }
        ];

        // Vertex shader
        const vertexShader = `
            uniform mat4 uMatrix;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment shader with day/night mixing
        const fragmentShader = `
            uniform sampler2D uDayTexture;
            uniform sampler2D uNightTexture;
            uniform vec3 uSunDirection;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vec3 dayColor = texture2D(uDayTexture, vUv).rgb;
                vec3 nightColor = texture2D(uNightTexture, vUv).rgb;
                
                // Calculate dot product between normal and sun direction
                float sunIntensity = dot(vNormal, uSunDirection);
                
                // Smoothstep for smooth transition between day and night
                float mixFactor = smoothstep(-0.5, 0.5, sunIntensity);
                
                vec3 color = mix(nightColor, dayColor, mixFactor);
                
                float spec = pow(max(dot(vNormal, uSunDirection), 0.0), 16.0) * 0.4;
                color += vec3(spec);

                gl_FragColor = vec4(color, 1.0);            }
                `;

        // Three.js setup
        const container = document.getElementById('globe-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x0a0a0a);
        container.appendChild(renderer.domElement);

        camera.position.z = 2.5;

        // Load textures
        const textureLoader = new THREE.TextureLoader();
        const dayTexture = textureLoader.load('./data/1_earth_8k.jpg');
        const nightTexture = textureLoader.load('./data/5_night_8k.jpg');
        
        // Set color space for proper color rendering
        dayTexture.colorSpace = THREE.SRGBColorSpace;
        nightTexture.colorSpace = THREE.SRGBColorSpace;

        // Create procedural starfield
        function createStarfield() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Generate random stars with varying brightness
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const brightness = Math.random();
                const size = brightness * 1.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.fillRect(x, y, size, size);
            }            
            return new THREE.CanvasTexture(canvas);
        }
        
        // Create starfield sphere
        const starfieldGeometry = new THREE.SphereGeometry(100, 64, 64);
        const starfieldTexture = createStarfield();
        const starfieldMaterial = new THREE.MeshBasicMaterial({
            map: starfieldTexture,
            side: THREE.BackSide,
            castShadow: false,
            receiveShadow: false
        });
        const starfield = new THREE.Mesh(starfieldGeometry, starfieldMaterial);
        scene.add(starfield);
        const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
        const globeMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uDayTexture: new THREE.Uniform(dayTexture),
                uNightTexture: new THREE.Uniform(nightTexture),
                uSunDirection: new THREE.Uniform(new THREE.Vector3(-1, 0.5, 0.2).normalize())
            }
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(5, 3, 5);
        scene.add(pointLight);

        // Add markers
        const markers = [];
        const markerGroup = new THREE.Group();
        globe.add(markerGroup);

        function latLngToVector3(lat, lng) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;
            const x = -Math.sin(phi) * Math.cos(theta);
            const y = Math.cos(phi);
            const z = Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z).normalize();
        }

        // Load pointer icon
        const textureLoader2 = new THREE.TextureLoader();
        const pointerTexture = textureLoader2.load('./data/mappointer.png');
        
        stickerData.forEach((sticker, index) => {
            const pos = latLngToVector3(sticker.lat, sticker.lng);
            
            // Create container for the sprite
            const spriteContainer = new THREE.Object3D();
            spriteContainer.position.copy(pos.multiplyScalar(1.02)); // Slightly offset from surface
            
            // Create sprite for the pointer icon
            const spriteMaterial = new THREE.SpriteMaterial({
                map: pointerTexture,
                sizeAttenuation: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.15, 0.15, 1);
            sprite.position.y = 0.03; // Offset so pin point aligns with location
            sprite.userData = { index, sticker };
            
            spriteContainer.add(sprite);
            markerGroup.add(spriteContainer);
            markers.push(sprite);
        });

        // Mouse interaction
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                globe.rotation.y += deltaX * 0.005;
                globe.rotation.x += deltaY * 0.005;
                
                // Rotate starfield opposite to globe
                starfield.rotation.y += deltaX * 0.005;
                starfield.rotation.x += deltaY * 0.005;
                
                // Rotate sun direction with the globe
                const sunDir = globeMaterial.uniforms.uSunDirection.value;
                const axis1 = new THREE.Vector3(0, 1, 0); // Y axis for horizontal drag
                const axis2 = new THREE.Vector3(1, 0, 0); // X axis for vertical drag
                
                sunDir.applyAxisAngle(axis1, deltaX * 0.005);
                sunDir.applyAxisAngle(axis2, deltaY * 0.005);
            }
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener('mouseup', () => {
            isDragging = false;
        });

container.addEventListener('wheel', (e) => {
    e.preventDefault();
    
    // Get current direction from camera to globe center
    const direction = new THREE.Vector3(0, 0, 0).sub(camera.position).normalize();
    
    // Adjust distance while maintaining direction
    const currentDistance = camera.position.length();
    const newDistance = currentDistance + e.deltaY * 0.001;
    const clampedDistance = Math.max(1.5, Math.min(5, newDistance));
    
    // Set camera position maintaining the direction but with new distance
    camera.position.copy(direction.multiplyScalar(-clampedDistance));
    camera.lookAt(0, 0, 0);
});

        // Sidebar
        const stickerList = document.getElementById('sticker-list');
        const stickerCount = document.getElementById('sticker-count');
        
        stickerCount.textContent = `${stickerData.length} stickers found`;

        stickerData.forEach((sticker, index) => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.innerHTML = `
                <div><strong>${sticker.title}</strong></div>
                <div class="sticker-date">${sticker.date}</div>
                <div class="sticker-coords">${sticker.lat.toFixed(4)}¬∞, ${sticker.lng.toFixed(4)}¬∞</div>
            `;
            item.addEventListener('click', () => selectSticker(index));
            stickerList.appendChild(item);
        });

 function selectSticker(index) {
    document.querySelectorAll('.sticker-item').forEach((item, i) => {
        item.classList.toggle('active', i === index);
    });

    // Reset all pins to original color
    stickerData.forEach((_, i) => {
        const spriteContainer = markerGroup.children[i];
        const sprite = spriteContainer.children[0];
        sprite.material.color.setHex(0xffffff); // White
    });

    // Change selected pin color
    const spriteContainer = markerGroup.children[index];
    const sprite = spriteContainer.children[0];
    sprite.material.color.setHex(0xe74c3c); // Red

    // Get the sprite container's world position (accounts for globe rotation)
    const worldPos = new THREE.Vector3();
    spriteContainer.getWorldPosition(worldPos);
    
    // Animate camera to orbit around the pin's current world location
    const targetDistance = 2.5;
    const targetPos = worldPos.clone().normalize().multiplyScalar(targetDistance);
    
    // Smoothly animate camera over 1 second
    const startPos = camera.position.clone();
    const startTime = Date.now();
    const duration = 1000;
    
    function animateCamera() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Smooth easing function
        const easeProgress = progress < 0.5 
            ? 2 * progress * progress 
            : -1 + (4 - 2 * progress) * progress;
        
        camera.position.lerpVectors(startPos, targetPos, easeProgress);
        camera.lookAt(0, 0, 0);
        
        if (progress < 1) {
            requestAnimationFrame(animateCamera);
        }
    }
    
    animateCamera();
}     
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isDragging) {
                globe.rotation.y += 0.0005;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>