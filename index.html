<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./data/mapPointer.png" type="image/png" />
    <title>Shroom Sticker Globe</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #0a0a0a; color: #fff; overflow: hidden;
      }
      .container { display: flex; height: 100vh; }
      #globe-container { flex: 1; position: relative; }
      .sidebar {
        width: 320px; background: #1a1a2eb9; overflow-y: auto; padding: 0;
        border-left: 3px solid #e74c3c; display: flex; flex-direction: column;
        font-family: "Courier New", monospace; image-rendering: pixelated;
        box-shadow: inset -4px 0 8px rgba(0,0,0,0.5);
      }
      .header {
        padding: 20px; background: #0f0f1e; position: sticky; top: 0; z-index: 10;
        border-bottom: 3px solid #e74c3c; box-shadow: 0 4px 0 rgba(231,76,60,0.3);
      }
      .header h1 {
        font-size: 18px; margin-bottom: 5px; font-weight: 700; letter-spacing: 2px;
        color: #e74c3c; text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
      }
      .header p { font-size: 10px; opacity: 0.8; letter-spacing: 1px; color: #aaa; }
      .sticker-count {
        font-size: 11px; font-weight: 600; padding: 12px 15px; background: #16213e;
        border-bottom: 2px solid #e74c3c; border-top: 2px solid #e74c3c; color: #e74c3c; letter-spacing: 1px;
      }
      #sticker-list { flex: 1; overflow-y: auto; padding: 8px; }
      .sticker-item {
        background: #16213e; border: 2px solid #333; padding: 12px; margin-bottom: 8px; cursor: pointer;
        transition: all 0.1s linear; position: relative;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.4), inset -1px -1px 0 rgba(0,0,0,0.3);
      }
      .sticker-item:hover {
        background: #1a2847; border-color: #e74c3c;
        box-shadow: 4px 4px 0 rgba(231,76,60,0.3), inset -1px -1px 0 rgba(0,0,0,0.5);
        transform: translate(-2px,-2px);
      }
      .sticker-item.active {
        background: #e74c3c; border-color: #c0392b; color: #fff;
        box-shadow: 4px 4px 0 rgba(0,0,0,0.5), inset 1px 1px 0 rgba(255,255,255,0.2);
        transform: translate(-3px,-3px);
      }
      .sticker-title {
        font-weight: 700; font-size: 12px; margin-bottom: 6px; display: flex;
        justify-content: space-between; align-items: center; letter-spacing: 0.5px;
      }
      .sticker-link {
        display: inline-flex; align-items: center; justify-content: center;
        width: 50px; height: 50px; background: #333; border: 1px solid #555;
        text-decoration: none; color: inherit; font-size: 10px; cursor: pointer;
        box-shadow: inset 1px 1px 0 rgba(255,255,255,0.1); transition: all 0.1s linear;
      }
      .sticker-item:hover .sticker-link { background: #e74c3c; border-color: #c0392b; }
      .sticker-item.active .sticker-link { background: rgba(0,0,0,0.2); border-color: rgba(0,0,0,0.4); }
      .sticker-coords {
        font-family: "Courier New", monospace; font-size: 9px; margin-bottom: 5px; color: #88ff88;
        letter-spacing: 1px; text-shadow: 0 0 3px rgba(136,255,136,0.3);
      }
      .sticker-date { font-size: 10px; color: #aaa; letter-spacing: 0.5px; }
      #sticker-list::-webkit-scrollbar { width: 12px; }
      #sticker-list::-webkit-scrollbar-track { background: #0f0f1e; border-left: 2px solid #333; }
      #sticker-list::-webkit-scrollbar-thumb {
        background: #e74c3c; border: 1px solid #c0392b; box-shadow: inset 1px 1px 0 rgba(0,0,0,0.5);
      }
      .controls {
        position: absolute; top: 20px; left: 20px; background: rgba(26,26,26,0.9);
        padding: 15px 20px; border-radius: 8px; border: 1px solid #333; font-size: 12px; z-index: 100;
      }
      .controls p { margin: 5px 0; color: #aaa; }
      .logo { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 100; }
      .logo img { height: 100px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); }
      @media (max-width: 768px) {
        .container { flex-direction: column; }
        .sidebar { width: 100%; height: 200px; border-left: none; border-top: 1px solid #333; }
        #globe-container { height: calc(100vh - 200px); }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="globe-container">
        <div class="logo">
          <img src="./data/ShroomSquad.png" alt="Shroom Squad Logo" />
        </div>
        <div class="controls">
          <p>üñ±Ô∏è Drag to orbit</p>
          <p>üîç Scroll to zoom</p>
        </div>
      </div>
      <div class="sidebar">
        <div class="header">
          <h1>Sticker Spots</h1>
          <p>Your global sticker collection</p>
        </div>
        <div class="sticker-count" id="sticker-count"></div>
        <div id="sticker-list"></div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Load sticker data from JSON file
      let stickerData = [];

      fetch("./data/stickers.json")
        .then((response) => response.json())
        .then((data) => {
          stickerData = data;
          initializeApp();
        })
        .catch((error) => {
          console.error("Error loading stickers.json:", error);
          stickerData = [];
          initializeApp();
        });

      function initializeApp() {
        // ===== Shaders (world-space lighting so camera doesn't affect it) =====
        const vertexShader = `
          varying vec2 vUv;
          varying vec3 vNormalWorld;

          void main() {
            vUv = uv;
            vNormalWorld = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const fragmentShader = `
          uniform sampler2D uDayTexture;
          uniform sampler2D uNightTexture;
          uniform vec3 uSunDirectionWorld;

          varying vec2 vUv;
          varying vec3 vNormalWorld;

          void main() {
            vec3 dayColor = texture2D(uDayTexture, vUv).rgb;
            vec3 nightColor = texture2D(uNightTexture, vUv).rgb;

            float sunIntensity = dot(vNormalWorld, normalize(uSunDirectionWorld));
            float mixFactor = smoothstep(-0.1, 0.1, sunIntensity);

            vec3 color = mix(nightColor, dayColor, mixFactor);
            float spec = pow(max(dot(vNormalWorld, normalize(uSunDirectionWorld)), 0.0), 16.0) * 0.4;
            color += vec3(spec);

            gl_FragColor = vec4(color, 1.0);
          }
        `;

        // ===== Three.js setup =====
        const container = document.getElementById("globe-container");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          10000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x0a0a0a);
        container.appendChild(renderer.domElement);

        // ---- ORBIT STATE ----
        const orbit = {
          radius: 2.5,
          theta: 0,
          phi: Math.PI / 2,
          minRadius: 1.5,
          maxRadius: 5.0,
          minPhi: 0.05,
          maxPhi: Math.PI - 0.05,
          lockedMarker: null
        };

        // Simple animation token to allow cancellation on drag
        let orbitAnim = null; // { cancel: boolean }

        function updateCameraFromOrbit() {
          const x = orbit.radius * Math.sin(orbit.phi) * Math.sin(orbit.theta);
          const y = orbit.radius * Math.cos(orbit.phi);
          const z = orbit.radius * Math.sin(orbit.phi) * Math.cos(orbit.theta);
          camera.position.set(x, y, z);
          camera.lookAt(0, 0, 0);
        }

        updateCameraFromOrbit();

        // Textures
        const textureLoader = new THREE.TextureLoader();
        const dayTexture = textureLoader.load("./data/1_earth_8k.jpg");
        const nightTexture = textureLoader.load("./data/5_night_8k.jpg");
        dayTexture.colorSpace = THREE.SRGBColorSpace;
        nightTexture.colorSpace = THREE.SRGBColorSpace;

        // Starfield (static)
        function createStarfield() {
          const canvas = document.createElement("canvas");
          canvas.width = 2048; canvas.height = 1024;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < 1000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const b = Math.random();
            const size = b * 1.5;
            ctx.fillStyle = `rgba(255,255,255,${b})`;
            ctx.fillRect(x, y, size, size);
          }
          return new THREE.CanvasTexture(canvas);
        }

        const starfieldGeometry = new THREE.SphereGeometry(100, 64, 64);
        const starfieldTexture = createStarfield();
        const starfieldMaterial = new THREE.MeshBasicMaterial({
          map: starfieldTexture, side: THREE.BackSide, castShadow: false, receiveShadow: false,
        });
        const starfield = new THREE.Mesh(starfieldGeometry, starfieldMaterial);
        scene.add(starfield);

        // Globe
        const globeGeometry = new THREE.SphereGeometry(1, 16, 10);
        const globeMaterial = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader,
          uniforms: {
            uDayTexture: new THREE.Uniform(dayTexture),
            uNightTexture: new THREE.Uniform(nightTexture),
            uSunDirectionWorld: new THREE.Uniform(new THREE.Vector3(-1, 0.5, 0.2).normalize()),
          },
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Moon
        const moonGeometry = new THREE.SphereGeometry(0.27, 8, 6);
        const moonTexture = textureLoader.load("./data/moon.jpg");
        moonTexture.colorSpace = THREE.SRGBColorSpace;
        const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 1, metalness: 0 });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(3, 0, 0);
        globe.add(moon);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(5, 3, 5);
        scene.add(pointLight);

        // --- Marker scaling config (relative to zoom) ---
        const markerScale = {
          base: 0.15,           // scale at referenceRadius
          min: 0.07,            // absolute minimum world-scale
          max: 0.30,            // absolute maximum world-scale
          referenceRadius: 2.5  // radius at which base applies (matches initial orbit)
        };

        // Markers
        const markers = [];
        const markerGroup = new THREE.Group();
        globe.add(markerGroup);

        function latLngToVector3(lat, lng) {
          const phi = ((90 - lat) * Math.PI) / 180;
          const theta = ((lng + 180) * Math.PI) / 180;
          const x = -Math.sin(phi) * Math.cos(theta);
          const y = Math.cos(phi);
          const z = Math.sin(phi) * Math.sin(theta);
          return new THREE.Vector3(x, y, z).normalize();
        }

        const pointerTexture = new THREE.TextureLoader().load("./data/mapPointer.png");

        stickerData.forEach((sticker, index) => {
          const pos = latLngToVector3(sticker.lat, sticker.lng);

          const spriteContainer = new THREE.Object3D();
          spriteContainer.position.copy(pos.multiplyScalar(1.02));

          const spriteMaterial = new THREE.SpriteMaterial({ map: pointerTexture, sizeAttenuation: true });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(markerScale.base, markerScale.base, 1); // initial; will be updated per-zoom
          sprite.position.y = 0.03;
          sprite.userData = { index, sticker };

          spriteContainer.add(sprite);
          markerGroup.add(spriteContainer);
          markers.push(sprite);
        });

        // --- Scale markers based on orbit.radius with clamped limits ---
        function updateMarkerScales() {
          const factor = orbit.radius / markerScale.referenceRadius; // >1 when zoomed out; <1 when zoomed in
          const s = THREE.MathUtils.clamp(markerScale.base * factor, markerScale.min, markerScale.max);
          for (let i = 0; i < markers.length; i++) {
            markers[i].scale.set(s, s, 1);
          }
        }
        // initial scale
        updateMarkerScales();

        // ----- Mouse interaction -----
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const dragSensitivity = 0.005;
        const dragSensitivityY = 0.005;

        container.addEventListener("mousedown", (e) => {
          isDragging = true;
          // Cancel any running animation and unlock marker on drag start
          if (orbitAnim) orbitAnim.cancel = true;
          orbit.lockedMarker = null;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          orbit.theta -= deltaX * dragSensitivity;
          orbit.phi   -= deltaY * dragSensitivityY;
          orbit.phi = Math.max(orbit.minPhi, Math.min(orbit.maxPhi, orbit.phi));

          updateCameraFromOrbit();

          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        container.addEventListener("mouseup", () => { isDragging = false; });
        container.addEventListener("mouseleave", () => { isDragging = false; });

        // Zoom (adjust orbit radius)
        container.addEventListener("wheel", (e) => {
          e.preventDefault();
          const zoomFactor = 0.0015;
          const newRadius = orbit.radius + e.deltaY * zoomFactor;
          orbit.radius = Math.max(orbit.minRadius, Math.min(orbit.maxRadius, newRadius));
          updateCameraFromOrbit();
          updateMarkerScales(); // reflect zoom immediately
        }, { passive: false });

        // Sidebar
        const stickerList = document.getElementById("sticker-list");
        const stickerCount = document.getElementById("sticker-count");
        stickerCount.textContent = `${stickerData.length} stickers found`;

        stickerData.forEach((sticker, index) => {
          const item = document.createElement("div");
          item.className = "sticker-item";
          item.innerHTML = `
            <div class="sticker-title">
              <span>${sticker.title}</span>
              <a href="${sticker.link}" target="_blank" rel="noopener noreferrer"
                 class="sticker-link" title="Open Instagram post">üì∑</a>
            </div>
            <div class="sticker-coords">${sticker.lat.toFixed(4)}¬∞, ${sticker.lng.toFixed(4)}¬∞</div>
            <div class="sticker-date">${sticker.date}</div>
          `;
          item.addEventListener("click", (e) => {
            if (e.target.tagName !== "A") { selectSticker(index); }
          });
          stickerList.appendChild(item);
        });

        // Utility: vector -> spherical angles
        function vectorToAngles(v) {
          const vn = v.clone().normalize();
          const phi = Math.acos(THREE.MathUtils.clamp(vn.y, -1, 1)); // 0..PI
          const theta = Math.atan2(vn.x, vn.z); // -PI..PI
          return { theta, phi };
        }

        function shortestAngleDelta(a, b) {
          let d = b - a;
          while (d > Math.PI) d -= 2 * Math.PI;
          while (d < -Math.PI) d += 2 * Math.PI;
          return d;
        }

        function easeInOutQuad(t) {
          return t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
        }

        function animateOrbitTo(targetTheta, targetPhi, duration = 700, onDone = () => {}) {
          // Cancel any existing animation
          if (orbitAnim) orbitAnim.cancel = true;

          const token = { cancel: false };
          orbitAnim = token;

          const startTheta = orbit.theta;
          const startPhi = orbit.phi;
          const dTheta = shortestAngleDelta(startTheta, targetTheta);
          const dPhi = targetPhi - startPhi;

          const t0 = Date.now();

          function step() {
            if (token.cancel) return;
            const t = Math.min((Date.now() - t0) / duration, 1);
            const e = easeInOutQuad(t);

            orbit.theta = startTheta + dTheta * e;
            orbit.phi   = startPhi   + dPhi   * e;

            updateCameraFromOrbit();
            updateMarkerScales(); // keep scale smooth during fly-to

            if (t < 1) {
              requestAnimationFrame(step);
            } else {
              onDone();
            }
          }
          requestAnimationFrame(step);
        }

        function selectSticker(index) {
          document.querySelectorAll(".sticker-item").forEach((item, i) => {
            item.classList.toggle("active", i === index);
          });

          // Reset colours
          stickerData.forEach((_, i) => {
            const spriteContainer = markerGroup.children[i];
            const sprite = spriteContainer.children[0];
            sprite.material.color.setHex(0xffffff);
          });

          // Highlight selected pin
          const spriteContainer = markerGroup.children[index];
          const sprite = spriteContainer.children[0];
          sprite.material.color.setHex(0xe74c3c);

          // Determine target orbit angles to face the marker
          const worldPos = new THREE.Vector3();
          spriteContainer.getWorldPosition(worldPos);
          const { theta: targetTheta, phi: targetPhiRaw } = vectorToAngles(worldPos);
          const targetPhi = THREE.MathUtils.clamp(targetPhiRaw, orbit.minPhi, orbit.maxPhi);

          // During animation: ensure we are not locked (we'll lock after)
          orbit.lockedMarker = null;

          // Animate camera to marker direction, then lock to it
          animateOrbitTo(targetTheta, targetPhi, 700, () => {
            if (orbitAnim && orbitAnim.cancel) return;
            orbit.lockedMarker = spriteContainer;
          });
        }

        // Animation loop
        let moonOrbitAngle = 0;
        const moonOrbitRadius = 3;
        const moonOrbitSpeed = 0.001;

        function animate() {
          requestAnimationFrame(animate);

          // Gentle Earth spin (optional)
          globe.rotation.y += 0.0005;

          // Orbit the moon around Earth
          moonOrbitAngle += moonOrbitSpeed;
          moon.position.x = Math.cos(moonOrbitAngle) * moonOrbitRadius;
          moon.position.z = Math.sin(moonOrbitAngle) * moonOrbitRadius;
          moon.rotation.y += 0.001;

          // While locked: keep following the marker as Earth spins
          if (orbit.lockedMarker) {
            const worldPos = new THREE.Vector3();
            orbit.lockedMarker.getWorldPosition(worldPos);
            const { theta, phi } = vectorToAngles(worldPos);
            orbit.theta = theta;
            orbit.phi   = THREE.MathUtils.clamp(phi, orbit.minPhi, orbit.maxPhi);
          }

          updateCameraFromOrbit();
          updateMarkerScales(); // keep marker size in sync every frame
          renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
          updateCameraFromOrbit();
          updateMarkerScales();
        });
      }
    </script>
  </body>
</html>
